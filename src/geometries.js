// Geometries are the foundation of all 3D shapes: cube, donut or custom spaceship

// A geometry is a mathematical structure that defines the form of a 3D object
// Vertices: points in 3D space
// Edges: lines connecting the vertices
// Faces: the surfaces created by the edges

import "./style.css";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

const material = new THREE.MeshBasicMaterial({
  color: "green",
  // side: THREE.DoubleSide, // renders front and back
});
// SphereGeometry: More segments = more smoothness = require more processing power
// const sphereGeometry = new THREE.SphereGeometry(1, 32, 32); // Radius, Width Segments, Height Segments
// const sphere = new THREE.Mesh(sphereGeometry, material); // looks like earth globe

// const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32); // Top Radius, Bottom Radius, Height, Radial Segments
// const cylinder = new THREE.Mesh(cylinderGeometry, material);

// Specialized version of the cylinder where the top radius is zero, creating a cone shape.
// const coneGeometry = new THREE.ConeGeometry(0.5, 2, 32); // Bottom Radius, Height, Radial Segments
// radial segments -> smoothness of radius plane
// const cone = new THREE.Mesh(coneGeometry, material);

// Create a flat, 2D plane
// Useful for flat surfaces like floors, walls, or even simple 2D shapes.
// const planeGeometry = new THREE.PlaneGeometry(5, 5); // Width, Height
// const plane = new THREE.Mesh(planeGeometry, material); // unable to see back of plane without wireframe

// For creating rings, donuts, or any other torus-shaped objects.
// const torusGeometry = new THREE.TorusGeometry(1, 0.4, 16, 100); // Radius, Tube Radius, Radial Segments, Tubular Segments
// Radial Segments → smoothness of the side wall of the tube (what you noticed when rotating to the side).
// Radial Segments = tube’s girth smoothness

// Tubular Segments → smoothness of the outer ring path (what you noticed when looking from the front).
// Tubular Segments = ring’s path smoothness

// Radial Segments → smoothness of the side wall of the tube (what you noticed when rotating to the side).
// Tubular Segments → smoothness of the outer ring path (what you noticed when looking from the front).

// change either radial or tubular to value of 2 for flat plane.
// const torus = new THREE.Mesh(torusGeometry, material);
// torus.rotation.x = Math.PI / 2;

// scene.add(sphere);
// scene.add(cylinder);
// scene.add(cone);
// scene.add(plane);
// scene.add(torus);

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// When you rotate the torus to the side, you’re looking at the outline of the tube’s thickness. That outline is literally the cross-section (the “circle” that gets swept around to make the ring).

// When you slice the torus in half (cut through the ring like a bagel), the shape you expose is also that same cross-section.

// So whether you:

// Look from the side → you see the silhouette of the tube’s cross-section.

// Cut it open → you directly see the cross-section.

// They match because the entire torus is generated by taking that cross-section and sweeping it around in a circle to form the donut.

// Custom Geometries: specify vertices and faces manually.

// Custom triangle:
// BufferGeometry is the low-level way to define custom shapes in Three.js.
// It works with arrays of numbers (vertices, indices, etc.).
const geometry = new THREE.BufferGeometry();

// define vertices of triangle
const vertices = new Float32Array([
  0,
  1,
  0, // vertex 1 (top middle)
  -1,
  -1,
  0, // vertex 2 (bottom left)
  1,
  -1,
  0, // vertex 3 (bottom right)
]);

// define the faces (indices of the vertices)
// Tells Three.js which vertices make up a face (triangle).
// optional: swap indices of v2 and v3 to render backface instead of face (CW instead of CCW)
const indices = new Uint16Array([0, 1, 2]); // Connect vertex 0 → 1 → 2 in order to form a triangle.
// the above indices represents each of the vertices that forms the triangle.

// Add the vertices and indices to the geometry

// Adds the vertex positions as an attribute.
// The 3 means each vertex has 3 components (x, y, z).
geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

// Adds the indices that define the triangle faces.
// The 1 means each index is just a single number.
geometry.setIndex(new THREE.BufferAttribute(indices, 1));

const triangle = new THREE.Mesh(geometry, material);
scene.add(triangle);

// This creates a simple triangle by defining three vertices and connecting them to form a face.
// A green triangle, lying flat on the XY-plane (z=0), pointing upward.

// Float32Array -> typed array in JavaScript
// Stores floating-point numbers (decimals) using 32 bits per number. (ASK MORE)
// Used in WebGL/Three.js because the GPU likes compact, predictable data formats.
const arr = new Float32Array([0.1, 2.5, -3.7]);
console.log(arr[1]); // 2.5
// In your code, it holds vertex positions (x, y, z).

// Uint16Array -> Another typed array
// Stores unsigned 16-bit integers (whole numbers from 0 → 65535). (ASK MORE)
// Much smaller and faster than using normal JS arrays when passing to the GPU.
// Perfect for indices, because indices are just integer references to vertices.
const arrTest = new Uint16Array([0, 1, 2]);
console.log(arrTest[2]); // 2

// What is a face?
// In 3D graphics, a face = a flat surface on a 3D object.
// Faces are built from vertices (points).

// Common cases:
// A triangle face = 3 vertices (most common in 3D because GPUs love triangles).
// A quad face = 4 vertices (usually broken down into 2 triangles internally).

// Example:
// A cube has 6 square sides, but each square is made of 2 triangles → so the cube has 12 triangular faces.
// Your code defines 1 face (a single triangle).

// Float32Array = raw vertex positions.
// Uint16Array = references telling Three.js how to connect vertices into faces.
// A face = that connected triangle surface you actually see.

// Terminologies:

// typed array -> hold ONE type of number: all floats or all integers
// Stores them in a very compact, fixed-size format (exactly what your graphics card (GPU) needs for speed)

// Floating-point numbers (fancy name for decimals)
// Computers store these with special math rules so they can handle both very small and very large numbers.
// So: Float32Array = "an array made for decimals".

// “32 bits per number”
// A bit is the smallest piece of information in a computer. It can only be 0 or 1 (like a light switch, off/on).
// A byte = 8 bits (enough to store one small number or a letter like “A”).
// 32 bits = 4 bytes.
// So each decimal number in Float32Array takes 4 bytes of memory.
// You don’t really need to do the math — just know it means each number has a fixed size so the GPU can read them super fast.

// Unsigned 16-bit integers (whole numbers 0 → 65535)
// Unsigned means it cannot be negative — only 0 and positive.
// 16-bit means each number is stored using 16 switches (bits).
// Uint16Array = "an array of whole numbers from 0 to 65535".

// ✅ Putting it together:

// Float32Array: "A neat tray of decimal numbers (x, y, z positions)".
// Uint16Array: "A neat tray of whole numbers (indices telling which points form triangles)".

// Int16Array (signed):
// One bit is reserved for the sign (positive/negative).
// That cuts the range in half.
// Range becomes −32,768 → +32,767.

// That’s the trade-off: unsigned gives you more positive room, signed gives you negatives.

// 2. Examples of Float32 huge and tiny values
// Float32 covers about −3.4 × 10^38 to +3.4 × 10^38.

// Huge:
// 3.4 × 10^38 =
// 340,000,000,000,000,000,000,000,000,000,000,000,000
// (a 3 with 38 zeros after it 😅).

// Tiny:
// 1.4 × 10^-45 =
// 0.0000000000000000000000000000000000000000000014
// (a decimal point followed by 44 zeros before the 14).

// 👉 So Float32 can represent both astronomically large numbers and microscopically small numbers — though you lose precision for very extreme values.

// ✅ Quick summary:

// Uint16Array:
// Unsigned: 0 → 65535.
// Signed (Int16Array): −32,768 → +32,767.

// Float32Array:
// Huge: up to 3.4 × 10^38.
// Tiny: as small as 1.4 × 10^-45.

// ✅ In short:

// Uint16Array = integers, 16 bits per number

// Float32Array = decimals (or floats), 32 bits per number

// This is exactly why in Three.js:

// vertex positions → Float32Array (need decimals for smooth placement in 3D space)

// indices → Uint16Array (just integer references to vertices)

// Why can't i see anything when i rotate my camera to see the back of the triangle: (face culling topic)

// Every triangle (face) in 3D graphics has a direction called the "normal".
// The "normal" is an imaginary arrow perpendicular to the surface, pointing outwards.

// By default, Three.js only renders the front side of faces.
// You’re seeing the back face, which is culled (not drawn).
// That’s why it disappears when you rotate behind it.

// How Three.js determines front vs back
// The order of vertices matters.
// By default, Three.js uses counter-clockwise winding:
// If you look at the triangle and the vertices are arranged counter-clockwise, that’s the front.
// Clockwise = back.

// How to see the back side

// Option A: render both sides -> side: THREE.DoubleSide  // renders front and back

// Option B: Flip the triangle
// Swap the vertex order to reverse the normal: [0, 2, 1]
// Now the “front” points the other way.

// ✅ Summary

// You can only see the front by default because Three.js culls back faces for performance.
// Use THREE.DoubleSide if you want to see it from both sides.

// 1. What “front” and “back” mean
// Every triangle in 3D has a normal vector. The normal points “out” from the surface. Three.js (and most graphics engines) renders only the front face by default to save performance.

// So we need a way to consistently define which side is the front. That’s where the vertex order (winding) comes in.

// Normals never flip physically in space just because your camera moves.
// What flips is the apparent vertex order from your viewing perspective.
// CCW vs CW is camera-independent — it’s a property of the triangle in world coordinates.
// But when you rotate the camera to look at the back, you now see the vertices in a clockwise order, which Three.js treats as the back face.

// Front Face (CCW)
// Camera looking at front of triangle.
// Vertex order V1 → V2 → V3 appears counter-clockwise.

// Back Face (CW) (what you see when you rotate the camera 180° around Y)
// You are now looking at the “back” side of the same triangle.
// Vertex order now appears clockwise: V1 → V3 → V2 (same vertices, just from opposite side).

// Backface Culling in Blender For Surprisingly Better Lighting ...Face culling, or back-face culling, is a computer graphics optimization technique that discards polygons (faces) that face away from the viewer, improving rendering performance by preventing the drawing of invisible surfaces. This is particularly useful for closed, solid 3D objects like cubes and spheres, where only a portion of the faces are ever visible at a given time. By eliminating these non-visible triangles before expensive rasterization and fragment shader operations, computational resources are conserved, resulting in faster rendering times and smoother graphics in applications like video games.

// What is a Regular Polygon? (3 side - triangle) (smallest possible polygon)
// A polygon is a closed, two-dimensional shape made of straight line segments connected end-to-end
